[{"categories":["Security"],"contents":"本篇同步發佈在 Medium 平台上 Medium 連結  在 HTTP 通訊協定的內容中， Request 和 Response 有標準化內容格式，並且都包含了 Header 和 Body。在簡單了解 Header 和 Body 後，將介紹幾個可以用來保護你網站的 HTTP Header！\n Header   大部分會包含：\n  URL\n  Http Request Method 請求方法 (Get、Post、DELETE、PUT…等)\n  Http Status Code 狀態碼 (1xx ：稍等、2xx：成功、3xx：重新導向、4xx：Client 端錯誤、5xx：Service 端錯誤)\n    其他額外資訊也會放在這裡，例如：Client-ID、User-Agent、Authorization …等。\n  Body  主要傳遞的訊息內容，其格式可能為 JSON、XML…等，但也可能是沒有內容的。   X-Frame-Options X-Frame-Options 可以用來避免駭客在某個惡意網站當中，使用 iframe 嵌入你的網站，進而做到 Clickjacking 攻擊。\nClickjacking 是什麼呢？顧名思義就是攔截你的點擊來做壞事。簡單來說就是掛羊頭買狗肉，網站的樣貌是一個心理測驗網站，但是當你點擊網站內的開始測驗按鈕時，其實是到駭客的粉絲頁按讚。\n以下為 X-Frame-Options 的各種設定：\n  DENY— 禁止任何人嵌入這頁網頁\n  SAMEORIGIN — 如果你想要寬鬆一點就可以使用 same origin ，那麼就會依據 DOM 的同源政策來判斷要嵌入你這頁的網站是否與你的網站同源\n  ALLOW-FROM https://某個網站.com/— 設定白名單，只允許某網站嵌入你的網頁\n  X-XSS-Protection 設定為：X-Xss-Protection: 1; mode=block\n這個欄位的值設定為 1，它的模式設定為 block，便能讓瀏覽器預設的 XSS 防護生效。\nX-Content-Type-Options 設定為：X-Content-Type-Options: nosniff\nX-Content-Type-Options 設定為 nosniff (不要探測的意思)，來避免 MIME sniffing 攻擊。\n什麼是 MIME sniffing 攻擊呢？\nMIME 的全名是 Multipurpose Internet Mail Extensions，最初是用於電子郵件方面，後來被 HTTP 採用，用來描述資源的類型，例如：圖片、影片、HTML 檔案…等。\n假設駭客在部落格上寫一篇美食文章，並且上傳一張假的圖片，而這張假的圖片雖然被命名為 .jpg 但實際上是 HTML 程式碼，裡面含有一些惡意的攻擊程式，當另一位使用者看到駭客這篇美食文章，便會到 Server 端下載這張 .jpg，到那位使用者的瀏覽器作呈現，那麼攻擊的時間點就發生在瀏覽器試圖探測這個檔案的類型，瀏覽器會發現這個檔案其實不是圖片，它是 HTML 程式碼，瀏覽器一旦發現它其實是 HTML 程式碼時，瀏覽器就會對這個 .jpg 以 HTML 的方式去執行，因此內涵的惡意程式碼就會在使用者的瀏覽器執行並造成攻擊。\n駭客就是利用瀏覽器會探測檔案資料類型的這個特性來達到他攻擊的目的。\nAccess-Control-Allow-Origin 根據 Same Origin Policy，只有相同來源的資源才可以相互存取，但現今網站功能愈來愈複雜，有時需要允許跨來源資源的存取。此時，便要好好設定 Access-Control-Allow-Origin。\n設定為：\n1.Access-Control-Allow-Origin：https://demo.com\n你可以設定網站的網址，允許它來存取。\n2.Access-Control-Allow-Credentials: true\n也可以允許它是不是能夠帶相對應的 Cookie 來到你的網站，如果允許的話就把 Credentials 設定為 true。\n3.Access-Control-Allow-Methods: GET\n也可以設定存取你的網站時，使用的 HTTP Request 是哪一個動詞，這邊的範例是 GET。\nHTTPS Strict Transport Security 確保你的網站都在安全的 HTTPS 下進行操作．這個設定會通知瀏覽器，此網站禁止使用 HTTP 方式載入，瀏覽器應該要把所有使用 HTTP 的請求全部替換成 HTTPS 請求。\n以下為一個設定的範例：\nStrict-Transport-Security: max-age=31536000; includeSubDomains\n它可以設定一個有效期限，在這個有效期限之內你所有網站的 HTTP 請求，都會使用 HTTPS 來進行；\n此外如果你的子網域也要套用這個設定，那就可以加上 includeSubDomains，就是包含子網域的意思。\n 保護 Cookie 的 Header HttpOnly 設定了 HttpOnly 的 Cookie 無法被客戶端的 JavaScript 程式碼存取，避免潛在的安全問題。\nSecure 設定了 Secure 的 Cookie 只能在使用 HTTPS 的情況下被傳輸。\n 額外補充 Chrome 90 網址列將預設使用 https:// 了 當 Chrome 預設使用 HTTPS 協定，對於支援 HTTPS 的網站，便可直接連接到 HTTPS 端點，而不需要從 http:// 重新導向到 https://；\n至於尚未支援 HTTPS 的網站，在 HTTPS 嘗試失敗後，包括名稱不符或是 DNS 解析失敗等連接錯誤，Chrome 便會回退使用 HTTP。\n此調整除了明顯改善安全性和隱私性之外，這個更改也能提高支援 HTTPS 網站的初始載入速度。\n","permalink":"https://GengDeWu.github.io/blog/security_http_header_protect_your_website/","tags":["HTTP Header","Header","XSS","Cookie"],"title":"(Security) 使用HTTP Header來保護你的網站吧 !"},{"categories":["Security"],"contents":"本篇同步發佈在 Medium 平台上 Medium 連結  前言 WebGoat 是專門用來練習漏洞的 Web 應用程式，所以裡面的網頁都是漏洞百出的，因此官方也建議在使用 WebGoat 練習時，最好是把網路中斷，以免有心人士利用，讓使用者反而變成受害者。\n此外，WebGoat 只供教育/練習使用，在這邊學到的任何技術都不能拿去測試外面的網頁，以免觸法！\n WebGoat 安裝 在官方 Github 上可以看到，安裝 WebGoat 有四種方式\n  Run using Docker Standalone Run from the sources Run with custom menu   接下來將使用第二種安裝方式做示範。\n1. 請先確認電腦上是否有安裝 JRE Java SE Downloads\n2. 到官方 github 上下載最新版 WebGoat WebGoat Github\n3. 執行所下載的檔案  Windows： java -jar webgoat-server-8.1.0.jar [ — server.port=8080] [ — server.address=localhost]\n  macOS： java -jar webgoat-server-8.1.0.jar\n  Notice：注意輸入執行指令後是否皆無錯誤訊息、是否該 port 已有其他服務\n 4. 輸入上述所設定的 Port 及 Server 網址，如果沒有特別設定則網址為：  http://localhost:8080/WebGoat\n 5. 先點選 Register new user 來建立一個新帳戶 6. 看到與下圖相同的 WebGoat 首頁就可以開始演練各種漏洞啦！  漏洞演練 : SQL Injection 至左邊選單 (A1) Injection → SQL Injection (intro) → Page 9\n 此處可以讓您練習如何組出 SQL Injection 的攻擊字串，取得資料庫中不屬於您的資料。\n 漏洞演練 : XSS (Cross Site Scripting) ","permalink":"https://GengDeWu.github.io/blog/security_webgoat/","tags":["WebGoat","SQL Injection","XSS"],"title":"(Security)WebGoat 安裝 \u0026 漏洞演練"},{"categories":["Parameterized Query"],"contents":"本篇同步發佈在 Medium 平台上 Medium 連結 很多人都知道 SQL Injection 的攻擊原理，也知道參數化查詢可以防止 SQL Injection，但是參數化查詢爲什麼能防止 SQL Injection呢？本篇文章主要說明的正是這個問題，在了解主要原因(不使用組字串方式執行 SQL)後，將帶你了解如何觀看 Execution Plan 上的差異。\n主要原因(不使用組字串方式執行 SQL)  像上述這樣丟進 SQL Server 的參數是不會被當作 SQL 語法去執行的，因此就算使用者輸入的參數有注入的語法也不會因此執行成功！\n在使用參數化查詢語法的情況下，SQL Server 會先將 SQL 語句進行編譯，之後再把使用者輸入的參數丟進先前編譯的 SQL 語句再次執行。而預處理的 SQL 語句除了防範 SQL injection 更提升了效能。\n接著將來看看使用不同的查詢在 SQL Server Execution Plan 上的差異！\n如何觀看 Execution Plan 上的差異 首先，我們要了解 SQL Server 收到一個指令後會做些什麼事情：\n實際上可能有些差異，但大致的步驟如下，\nSQL Server 收到 SQL 指令 \u0026ndash;\u0026gt; 進行語法解析、語意分析 \u0026ndash;\u0026gt; 編譯 SQL 生成執行計劃 \u0026ndash;\u0026gt;選擇執行計劃 \u0026ndash;\u0026gt;執行執行計劃。\n接著我們就來創建一張表並實際來看看以下三種查詢在 SQL Server 是怎麼被執行的：\n (1) 正常的查詢，執行有漏洞的 SP\n  (2) SQL Injection 查詢，執行有漏洞的 SP\n  (3) 參數化查詢，執行使用參數化寫法的 SP\n 首先創建一張 USERS 表，語法如下：\n 並且寫入一些測試資料，語法如下：\n 執行完上述語法後，此時資料庫內應會有這五筆資料：\n接下來分別測試三種查詢方式，並觀察其 Execution Plan，此處將使用 Store Procedure 做示範：\n首先，分別建立兩個 Store Procedure\nWrongSP (使用組字串的方式最後使用 EXEC 執行)  CorrectSP (使用參數化查詢方式)  (1) 正常的查詢，執行有漏洞的 SP  (2) SQL Injection 查詢，執行有漏洞的 SP  (3) 參數化查詢，執行使用參數化寫法的 SP  若不清楚物件類型的區別這邊幫大家擷取 Microsoft 的文件，該欄位內容如下：\n以上試驗應該可以看出三種查詢其在執行 Execution Plan 上是有差異的，\n(1) 正常的查詢： 執行三次 WrongSP，執行計畫結果為 → 使用 3 次 Proc，另外使用 2 次 Adhoc，我再舉一個例子可以更明顯看出原因，\n 一樣都是執行三次 WrongSP，我只改變了查詢條件的一個字便使用了三個不同的 Execution Plan，表示三次查詢皆沒有重用 Proc 的 Execution Plan！\n(2) SQL Injection 查詢： 執行三次 WrongSP，執行計畫結果為 → 使用 3 次 Proc，另外使用 2 次 Adhoc，會有這樣的結果在剛剛第一點的例子也解釋了這是因為沒有重用 Proc 的 Execution Plan！\n(3) 參數化查詢： 執行三次 CorrectSP，執行計畫結果為 → 使用 3 次 Proc，這表示了什麼？就是 Proc 的 Execution Plan 被重用了！\n經過上述說明，可以看到在第二個例子(SQL Injection 查詢)中，SQL 表示的含義是找出(UserName=\u0026rsquo;\u0026rsquo; 且 CellPhoneNumber=\u0026rsquo;') 或者 1=1 的所有 User，這段 SQL Injection 語法改變了原來自己的初衷，也就是 SQL 的語意發生了改變，而為什麼發生了改變呢？原因是沒有重用先前建立好的 Execution Plan(Proc)，造成 SQL Server 對注入後的 SQL 語法重新進行了編譯、生成 Execution Plan 並執行新的 Execution Plan。\n結語 參數化查詢爲什麼能防止 SQL Injection，主要是因為不使用「組字串」的方式來執行 SQL。而在第二部分觀看 Execution Plan 上的差異，可以得知執行計畫未被更改(也就是重用 Execution Plan)，是可以防止 SQL Injection 的。\n而 Insert/Update/Delete 也是一樣的道理，只要可以重用 Execution Plan，SQL 所要表達的語意就不會變化！\n","permalink":"https://GengDeWu.github.io/blog/sql_server_sql_injection/","tags":["SQL Server","SQL Injection","Parameterized Query","Execution Plan"],"title":"(SQL) 爲什麼參數化查詢可以防止SQL Injection/如何觀看Execution Plan上的差異"},{"categories":["Python"],"contents":"本篇同步發佈在 Medium 平台上 Medium 連結 到底這個 if name == \u0026lsquo;main':是什麼意思呢 ?\n首先，如果你永遠都只執行一個 Python 檔，而不引用別的 Python 檔案的話，那麼你不必知道這是什麼東西，反之則來好好理解它吧！\n我直接舉一個例子 🌰 首先先創建一個 test_Demo.py 然後寫入以下程式：\n然後執行 test_Demo.py 會得到：\n Taiwan main Taiwan Number Taiwan Number One !  接著在同一層的資料夾中建立名稱為 import_test_Demo.py 的檔案，寫入以下程式：\n然後執行 import_test_Demo.py 會得到：\n Taiwan test_Demo  簡而言之 name 會是當前檔案名稱，當檔案被直接運行時檔案名稱將為main 。 因此，\n 「單獨執行」時程式將被運行，if name == \u0026lsquo;main\u0026lsquo;成立 「被引用」時程式不被運行，if name == \u0026lsquo;main\u0026lsquo;不成立  為什麼要有 if name == \u0026lsquo;main'? 在於獨立撰寫一些 funtion 時，可以直接執行 funtion 單純的看這個 function 功能是否正常。然而，這一個 function 實際上可能是要給一個大的主程式所使用，如果每一次都要檢查 function 是否正常，都要執行 main，是一個費時費力的過程，若能直接執行 funtion 檢查功能是否正常，將相對有效率！\n簡而言之，我們透過「if name == \u0026lsquo;main'」來控制 funtion，可以將測試資料放在「if name == \u0026lsquo;main'」的裡面，當單純執行 function 的執行檔時，則會利用測試資料檢測其功能；當利用 main 呼叫 function 操作時，就不會執行測試資料！只會直接執行 main 所想代入之變數，傳到 function 運算後將結果回傳給 main！\n","permalink":"https://GengDeWu.github.io/blog/python_if_name_equal_main/","tags":["pytest","Unittest"],"title":"(Python)What is if __name__ == '__main__' in Python ?"},{"categories":["CSharp"],"contents":"本篇同步發佈在 Medium 平台上 Medium 連結 What is Yield？ Yield 就是 Microsoft .Net 中用來實作 iterator(迭代器) 設計模式的語法糖，透過編譯器幫你轉成較複雜的 Code。\n舉個例子 🌰 從 DB 取出使用者設定的信件排程資訊，每封信件的 Template 可能不同，最後送給寄信服務發送。將如何設計此系統的運作流程呢？\n一般作法: 將全部資料都儲存在 List物件中，最終再 return 到寄信服務，這將可能造成系統吃掉大量的記憶體，甚至發生 System.OutOfMemoryException 的錯誤！\n還沒完全載入 Mail 資訊記憶體就已經攀升至 2G 啦 💥\n使用 Yield 作法: 一樣的情境，只是將 mailList.Add(new Mail()) 改為 yield return new Mail()，執行順序將有明顯的變化，如下圖將會依序執行(1) → (2) → (3) → (4) → (2) → (3) → (4) ……，記憶體的使用也相對平穩許多。\n若有興趣也可以參考 Andrew 的部落格，裡頭清楚的說明編譯器是如何幫你產生繁雜的 IEnumerator 實作方式讓你隨隨便便就可以跟別人宣稱:看! 我的程式有用到 Iterator 這個設計模式喔 XD 🐂🐂🐂\nReference [C#: yield return] #1. How It Work ?\n【C#】Yield Return 與迭代器\n","permalink":"https://GengDeWu.github.io/blog/c_sharp_yield_return_iterator_pattern/","tags":["Yield","Iterator Pattern"],"title":"(C#) Yield Return and Iterator Pattern"},{"categories":["CSharp"],"contents":"本篇同步發佈在 Medium 平台上 Medium 連結 首先，String 與 StringBuilder 是不同的喔！\nString   命名空間:System\n  代表不變的字串，一旦設定好值，就不能更改它。\n  String 是字元的陣列，一個連續的記憶體，當要新增、修改、刪除、變動 String 時，就必須毀掉這個陣列重新建立一個字串，因此很耗效能\n  String 類別 (System) MicroSoft 文件連結\nStringBuilder   命名空間:System.Text\n  表示可變動的字元字串，此類別無法被繼承。\n  使用時機：預期對字串進行大量變更時、預計在迴圈內串連字串時。\n  不是 string，所以需要使用 .ToString() 轉成 String 型態。\n  在 .NET 中使用 StringBuilder 類別 MicroSoft 文件連結\n實際測試 1. 動態字串 Loop 10 次 可以看到兩者花費時間是差不多的，StringBuilder 快 String 一倍。\n2. 動態字串 Loop 100000 次 此時 StringBuilder 已經比 String 快上 1000 多倍了！\n3. 靜態字串 在靜態字串時，String 比 StringBuild 效能來的好！\n 結論：當您要動態處理字串時最好選用 StringBuilder 類別 ，靜態處理字串則選用 String 類別。\n ","permalink":"https://GengDeWu.github.io/blog/c_sharp_string_stringbuilder/","tags":["String","StringBuilder"],"title":"(C#) 動態處理字串 String V.S. StringBuilder 效能"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結 Call Stack 在了解這三樣東西之前，要先知道 JavaScript 是單執行緒 single thread 的程式語言，因此一次只能執行一個任務，而 JavaScript中等待執行的任務會放入一個堆疊，我們叫它為 Call Stack。\n以下是一個Call Stack的範例：\n 最終會依序印出：\nfoo\rbar\rbaz\r 瀏覽器執行上述JavaScript時，Call Stack這個容器是怎麼被操作的呢，讓我們看看下圖詳細的流程吧！\nCallback Queue 簡單來說Callback Queue就是各種非同步事件用來排隊的地方，一般認為就是用以下幾種分出不同的佇列，但實作部份要視瀏覽器決定，其中的順序是依照FIFO(先進先出)，以下是幾種會包含的任務:\n  Events(事件): EventTarget物件非同步分派到對應的Events物件\n  Parsing(解析): HTML parser\n  Callbacks(回調): 呼叫非同步回調函式\n  使用外部資源: 資料庫、檔案、Web I/O\n  DOM處理的反應: 回應DOM處理時的元素對應事件\n  在瀏覽器端的JavaScript程式語言中，除了一般的事件分派外，還有少數幾個內建的API與相關物件有類似的非同步機制，有一些簡單的樣式可以利用它們模擬出非同步的執行程式:\n  setTimeout\n  setInterval\n  XMLHttpRequest\n  requestAnimationFrame\n  WebSocket\n  Worker\n  某些HTML5 API，例如File API、Web Database API\n  有使用onload的API\n  舉個例子：\n假如非同步事件會和同步事件都一起被放進 Call stack，那麼就會造成阻塞blocking，例如我們發出一個HTTP請求，那麼在完成 response 之前，就會因為 JavaScript 單執行緒的特性，我們在網頁上都無法進行其它操作。\n為了避免這種問題，非同步事件裡的回調函式 callback function，它們會進入到 Callback Queue 裡面，等 Call stack 裡面沒有其它任務才會進入到 Call stack 執行。\nEvent Loop 上述提到非同步事件會等 Call stack 裡面沒有其它任務才會進入到 Call stack 執行，就是透過 Event loop 機制去做判斷的，其監測步驟如下:\n 確認 Call stack 裡面有沒有Job，沒有才確認步驟2 確認 Callback Queue 裡面有沒有Job，有的話就把最前面的Job移到 Call stack 執行完該Job，又會再回到步驟1，持續這個Loop  最後，推薦讀者們可以觀看以下影片，講者Philip Roberts搭配了JavaScript運行的動畫講解Event Loop的機制，非常詳細且清楚！\n  ","permalink":"https://GengDeWu.github.io/blog/javascript_eventloop/","tags":["javascript","Call Stack","Callback Queue","Event Loop"],"title":"(JavaScript)Call Stack, Callback Queue, Event Loop in JavaScript"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結 若還不清楚甚麼是提升Hoisting的話，可以先看看之前的介紹喔！因為文章內容有部分相關，所以必須先有 Execution Context 以及 Variable Object 的觀念後，會較能理解本篇的內容。\n1. 作用域Scope 最常見的解釋是：作用域是一個變數的生存範圍，若於作用域之外將失去存取此變數的權限。\n馬上來看一個範例：\n 在這段程式中，定義outer與inner兩個函式，並且都在自已的函式中宣告一個變數，但當我們執行到console.log (y) 時會出現Uncaught ReferenceError: y is not defined。\n這其實是因為 y 並不在outer的作用域中，所以他沒有存取 y變數的權限。但為什麼inner卻能夠存取到outer的 x 變數呢 ? 這是因為在inner的作用域中找不到 x 變數，所以JavaScript Engine試著向外尋找 x 變數，最後在outer中找到，最後便能印出1443的訊息！\n靜態作用域與動態作用域 JavaScript採用的是靜態作用域，函式的作用域在函式定義時就決定了。 而靜態作用域相對的是動態作用域，函式的作用 域是在函式呼叫的時候才決定的。 讓我們看一個例子來理解靜態作用域和動態作用域之間的區別：\n 上面的程式碼中：\n  第1行，定義了一個value，並賦值為1；\n  第3~5行，宣告一個函式funB，函式的功能是列印 value 這個變數的值;\n  第7~9行，宣告一個函式funA，函式內部重新建立了一個變數 value 這個變數賦值為2；在函式內部執行了 funB() 這個函式；\n  第12行，執行 funA() 這個函式\n   JavaScript採用的是靜態作用域，以下僅是為了解析兩者流程上的差異！\n 假設JavaScript採用靜態作用域，讓我們解析執行過程：\n執行funB函式，首先從 funB 函式內部查詢是否有變數 value ，如果沒有就根據撰寫的位置，查詢上面一層的程式碼，我們發現value等於1，所以結果會印出 1。\n假設JavaScript採用動態作用域，讓我們解析執行過程：\n執行funB函式，依然是從 funB 函式內部查詢是否有區域性變數 value。如果沒有， 就從呼叫函式的作用域，也就是從 funA 函式內部 查詢 value 變數，所以結果會印出 2。\n2. 閉包Closure 用一句話解釋閉包：閉包就是一個作用域，當今天一個函式在返回一個作用域的時候，變數就會被存在作用域的裡面，不會被回收。\n想必目前應該是有看沒有懂，讓我們用範例來解釋甚麼是返回一個作用域，甚麼是變數就會被存在作用域的裡面不會被回收！\n馬上來看以下的範例，下方的outer(666)這時候到底是甚麼呢？Console.log它結果馬上揭曉！\n 原來這時的outer(666)返回了一個inner函式[作用域]，剛剛的第一個問題返回一個作用域馬上獲得了解釋！\n 接下來，執行這段程式碼，神奇的事情發生了，那就是程式碼依舊輸出了 1443。\n神奇在哪裡？神奇在一個 function 執行完成以後本來會把所有相關的資源釋放掉，可是我 outer 函式已經執行結束了，照理來說變數 x, y的記憶體空間也會被釋放，但我呼叫 inner 函式的時候居然還存取得到 x, y！\n換句話說，x, y這兩個變數被「關在」inner 這個 function 裡面了，所以只要 inner 還存在的一天，x, y就永無安寧，只能一直被關 在裡面。\n而事情的主因就是我在 function 裡面回傳了一個 function，才能造成這種明明執行完畢卻還有東西被關住的現象，而這種情形就是一 般人所熟知的閉包，Closure。\n以上便解釋了變數就會被存在作用域的裡面不會被回收！\n將上述的例子套上解釋閉包的一句話，便能有豁然開朗的感覺！\n閉包就是一個作用域，當今天一個函式outer在返回一個作用域outer(666)的時候，變數x, y就會被存在作用域的裡面，不會被 回收，因此可以正常輸出1433。\n Note：JavaScript Engine的垃圾回收機制會釋放不再使用的記憶體，但閉包為了保留函式和存取其語彙範疇的能力，就會予以保留， 不做記憶體回收。因此 inner 仍然保留指向 outer 內層範疇的參考，這個參考就是閉包。\n ","permalink":"https://GengDeWu.github.io/blog/javascript_scope_closure/","tags":["javascript","scope","closure"],"title":"(JavaScript)What is a closure? 解析作用域Scope \u0026 閉包Closure"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結  在前一篇有提到pass by reference與pass by sharing的原理，那當我們要拷貝物件型別的資料時該如何實作呢，以下就讓我們來看看吧!\n 淺拷貝 Array  使用arr.slice(0)   使用展開運算子[…arr]   Object  使用Object.assign({}, obj1)   使用展開運算子{…obj}   淺拷貝會遇到的問題 當物件中含有物件時，淺拷貝僅能拷貝物件的第一層，第二層之後它的記憶體位址還是指向相同位置，如下範例：\n 深拷貝 透過Lodash Library來做深拷貝，網址如下：\nLodash A JavaScript utility library delivering consistency, modularity, performance, \u0026amp; extras.\n在第8行使用Lodash CDN引入，在第18行使用 _.cloneDeep(obj1); 做深拷貝的動作，就能將多層物件通通都拷貝啦!\n Lodash也提供了相當多實用的函式，對經常處理資料的使用者可以省去很多時間，Lodash Methods 共分為以下幾種，若有興趣可至Lodash網站深入研究喔!\n- Array\r- Collection\r- Date\r- Function\r- Lang\r- Math\r- Number\r- Object\r- Seq\r- String\r- Util\r- Properties\r- Methods\r ","permalink":"https://GengDeWu.github.io/blog/javascript_shallowcopy_deepcopy_lodash/","tags":["javascript","Pass by value","Pass by reference","Pass by sharing","Shallow Copy","Deep Copy","Lodash"],"title":"(JavaScript)淺拷貝Shallow Copy \u0026 深拷貝Deep Copy — 使用Lodash來處理資料吧!"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結  這篇希望能透過一些簡單的範例，讓讀者們能夠輕易了解JavaScript的語言特性。\n Data Type 在JavaScript裡，有多種的資料型別(Data Type)，但主要分為兩大類，一類是原始型別(Primitive Type)，另一類是物件型別(Object Type)。\n原始型別 Primitive Type   String\n  BigInt\n  Number\n  Boolean\n  Null\n  Undefined\n  Symbol（ 在 ECMAScript 6 定義）\n  物件型別 Object Type  Primitive type以外的，例如object, array, function …等   一般來說，Primitive Type會是pass by value，而Object Type則會是pass by reference，以下會用幾個簡單例子來示範。\n 1. 原始型別 Pass by value 變數、記憶體位址、值 首先，要先來了解在電腦的底層世界，想像記憶體空間就像是一個一個的空間，每一個空間都有他的位址，並可以在該空間內儲存值。為了方便取用，才有了「變數」的存在，拿來連結(指向)這些記憶體位址，宣告變數賦值，就是向電腦要一個記憶體空間來儲存值。\n var a = \u0026lsquo;jerry\u0026rsquo;; ，其實是變數 a 指向電腦中某記憶體的位置(ex: 0x01) ，在這個記憶體位置中，儲存 jerry這個值。\n如果我再宣告了一個 var b = a; ，雖然 b 和 a 的值一樣都是 \u0026lsquo;jerry\u0026rsquo; ，但其實變數 b 是指向了另一個不一樣的記憶體位置 (ex:0x02)，把 a 的值 copy 過來存，a 和 b 是存在於兩個獨立不同的記憶體位置中：\n在第7行b = \u0026lsquo;tony\u0026rsquo;;，則是將記憶體位址0x02儲存的值賦予為tony，如下圖 :\n2. 物件型別 Pass by reference  var arr1 = [1,2,3]; ，表示 arr1 指向一個新的記憶體位置(ex: 0x01)，如果再建立第二個陣列並且讓他等於 arr1： var arr2 = arr1; ，這時 arr2 則會直接指向 arr1 的記憶體位置(0x01)，所以不論 arr1 儲存的值為多少， arr2 都會得到一樣的值：\n 在第3行arr2[0] = 666;，則是將記憶體位址0x01儲存的值index 0 賦予為666，如下圖 :\n3. Pass by sharing pass by sharing 的定義就有點像融合了pass by value 和 pass by reference：\n  碰到原始型別，表現行為是 pass by value。\n  碰到物件型別，如果只是改變內容，表現行為是 pass by reference，但是如果對物件作重新賦值，表現行為是 pass by value。\n  所以才會出現這一派的論點，覺得 Javascript 其實是 pass by sharing。\n 以下的流程分解圖可以更清楚了解物件指向的記憶體位置!\n第1～4行\n第5行\n第6行，改變內容(pass by reference)\n第7～10行，重新賦值(pass by value)\n第11行\n由以上範例可得知，book 在第6行被改變內容(pass by reference)，在第7~10行被重新賦值(pass by value)，因此bookObj1、bookObj2最終才會有此差異。\n 結論：在不管名詞定義為何(有些人認為只有pass by sharing)，先以行為來分類的話，primitive type基本上是pass by value，而object基本上是 pass by reference，唯一要注意的是重新賦值這個動作造成reference改變所造成的影響。\n 下一篇將會來討論：淺拷貝Shallow Copy \u0026amp; 深拷貝Deep Copy，並且使用Lodash來處理資料\n","permalink":"https://GengDeWu.github.io/blog/javascript_passbyvalue_reference_sharing/","tags":["javascript","Pass by value","Pass by reference","Pass by sharing"],"title":"(JavaScript)傳值 Pass by value、傳址 Pass by reference以及Pass by sharing"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結 用Javascript來做加減乘除，如果是使用小數的話，跑出來的數字會非常奇特，主要問題在於Javascript運算是依循IEEE754的規範，在運算時會轉換成二進制來計算數值，而浮點數在轉成二進制時會形成無窮迴圈，最後再轉換成十進制，進而產生運算誤差。\n舉個例子，0.1 + 0.2，在Javascript會是這樣子計算的。\n解決方法  1. 引入math.js\n 詳細流程可以參考此篇文章 优秀的js拓展数学库math.js，解决精度问题\n 2. 自訂加減乘除運算程式碼\n 加.add()、減.sub()、乘.mul()、除.div()\n 引入下方的javascript就能正常使用加減乘除運算啦!\n ","permalink":"https://GengDeWu.github.io/blog/javascript_float_calculation/","tags":["javascript"],"title":"(JavaScript)JavaScript 浮點數陷阱/解決方法"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結 What is hoisting? 在JavaScript中宣告的變數和函式，會被JavaScript直譯器 (interpreter) 先處理，換句話說，當你在 global 或 function 任何一個位置宣告變數，就像在該 scope 最頂端的位置宣告一樣，這種特性就叫做 Hoisting (提升)。\n在我們定義變數、函式的過程中，可以分成 宣告(declaration) 和 賦值(initialization) 兩個過程，只有宣告的內容會在逐行執行程式前先被執行並儲存在記憶體中(hoisting)；賦值的內容則是在hoisting後，逐行執行程式時，才會被執行到。\n大綱   (var)變數宣告的提升\n  (function)函式宣告的提升\n  (let/const)宣告與Temporal Dead Zone\n  1. (var)變數宣告的提升  正常印出值\n   印出undefined\n   從編譯器的角度來看\n  2. (function)函式宣告的提升 透過以下的幾個例子，可以得知變數的提升只有宣告部份，而函式的提升是整個函式，因此函式在宣告前是可以執行的。\n           3. (let/const)宣告與Temporal Dead Zone let 與 const 也有 hoisting，與 var 的差異在於提升之後，var 宣告的變數會變為 undefined，而 let 與 const 的宣告不會變為 undefined，且在「提升之後」、「賦值之前」的這段期間就存取它，就會拋出錯誤，而這段期間就稱做是 TDZ(Temporal Dead Zone)。\n  ","permalink":"https://GengDeWu.github.io/blog/javascript_hoisting/","tags":["javascript","hoisting"],"title":"(JavaScript)What is hoisting in JavaScript?"},{"categories":["SQL Server"],"contents":"本篇同步發佈在Medium平台上 Medium連結 在使用SQL Server資料庫時，若該環境是多人共用且大家都使用最高權限的帳號在操作資料庫時，就有機會發生資料庫被誤刪的情況，本篇僅能查出是哪位User(Login SQL Server Account)哪台Computer(HostName)做了刪除動作，要確保資料庫的安危還是需定期備份並且做好帳號的權限管理才是比較正確的做法。\n前置動作(產出Creat/Drop事件)   使用sa帳號登入SQL Server\n  建立一個名稱為TestDropDB的資料庫\n  使用test001帳號登入SQL Server\n  刪除TestDropDB資料庫\n  Step1. 確認SQL Server Log路徑  Step2. 顯示出要查詢的資料庫事件  以上就能很清楚的看到TestDropDB先被主機名稱為MSI、SQL Server帳號為sa的使用者建立，再被主機名稱為MSI、SQL Server帳號為test001的使用者給刪除。\n","permalink":"https://GengDeWu.github.io/blog/sql_server_find_which_user_deleted_the_database-copy/","tags":["SQL Server"],"title":"(SQL Server)How to Find which user deleted the database in SQL Server"},{"categories":["SQL Server"],"contents":"本篇同步發佈在 Medium 平台上 Medium 連結 第一次安裝完 Microsoft SQL Server 登入時可能會遇到 Error 18456 的問題\n發生原因 使用 SQL Server 驗證，因沒有設定使用 SQL Server 驗證登入，進而產生(Microsoft SQL Server, 錯誤: 18456)\n解決方法  先使用 Window 驗證進行登入  對資料庫點擊右鍵並選擇屬性  選擇安全性 → 伺服器驗證區塊勾選 SQL Server 及 Windows 驗證模式(S) → 確定  會跳出此提示訊息，必須重啟 SQL Server Service 後上述的設定才會生效  在重啟服務之前我們先確認 SQL Server 登入帳號是否有啟用，安全性 → 找到要登入的帳號名稱 → 點擊右鍵選擇[屬性]  選擇狀態 → 登入區塊勾選已啟用(E) → 確定  對資料庫點擊右鍵並選擇重新啟動  點選[是]，便會開始重啟 SQL Server Service  完成以上流程就能使用 SQL Server 驗證登入啦!  ","permalink":"https://GengDeWu.github.io/blog/sql_server_error_18456/","tags":["SQL Server"],"title":"(SQL Server) Microsoft SQL Server Error 18456"},{"categories":["IFTTT"],"contents":"本篇同步發佈在Medium平台上 Medium連結 IFTTT是個網路服務平台，縮寫的意思是IF(if)T(this)T(then)T(that)，顧名思義就是「如果這樣然後就那樣」，例如：如果時間到17:30然後Line發訊息通知我該下班了！\n在不用寫什麼程式的情況下，只需有IFTTT以及Line就能輕鬆實現「觸發某件事時，就自動發送Line通知訊息給某人/群組」。\n以下就讓我們來看如何輕鬆地完成這些設定，讓你/妳的生活更加方便吧！\n1. 進入IFTTT網站點選「Sign up」註冊帳號並登入 IFTTT Get started with IFTTT, the easiest way to do more with your favorite apps and devices for free.\n登入後選擇Get more便能瀏覽IFTTT目前能夠串連的服務\n今天的主題是要串連Line，我們點選Services頁籤並搜尋「Line」，便能選擇Line Service。\n點選Line後可以看到一個 Connect 按鈕，點選 Connect 就可以連結 LINE 官方所提供的 Notify 通知服務。\n登入你的Line帳號\n登入後點選「同意並連動」，同時LINE Notify會發給你一則訊息**「已完成與「IFTTT」的連動。請將此帳號邀請至欲接收訊息的LINE群組中。」**，之後就是LINE Notify這個好友會發送通知給你。\n2. 點選右上角的Create開始打造你的第一個IFTTT服務吧 點選+的圖示，設定觸發條件\n我想創建一個當時間一到就通知我下班的IFTTT服務，因此我輸入**「**date**」**並搜尋，點選Date \u0026amp; Time\n此處我選擇 Every day of the week at 並且設定我想收到通知的時間\n點選+的圖示，設定通知方式\n我想由Line通知我訊息，因此我輸入**「line」**並搜尋，點選Line\n點選Send message\n Recipient:選擇要傳送的群組 Message:輸入想收到的訊息 Photo URL:輸入圖片URL\n 編輯完成後點選Create action便完成設定啦!\n成功在設定的時間收到Line Notify通知訊息啦!\nIFTTT的應用非常廣泛且多元，也歡迎大家分享實用的IFTTT唷!\n","permalink":"https://GengDeWu.github.io/blog/ifttt_line_notify/","tags":["IFTTT","Line Notify"],"title":"IFTTT Use Line Notify"},{"categories":["Jenkins"],"contents":"本篇同步發佈在Medium平台上 Medium連結 Visual Code Grepper(VCG) 這套免費的源碼檢測工具，在功能性與準確性上並不輸給動輒幾百萬的商業檢測工具，唯一的差別應該只在於商業工具會提供較完美的圖表測試報告。\n本篇將示範Jenkins整合Visual Code Grepper自動產出三種格式(.txt、.csv、.xml)的報告。\n1. 首先必需先下載Visual Code Grepper Download VisualCodeGrepper V2.2.0 for free. Code security review tool for C/C++, C#, VB, PHP, Java, PL/SQL, COBOL.\n2. 找到VisualCodeGrepper.exe存放的位置 3. 在Jenkins專案中加入執行Windows批次指令   VCGPath：VisualCodeGrepper.exe的位置\n  Scan：要掃描的程式碼位置\n  ResTXT、ResCSV、ResXML：產出報告的位置\n  下方為VisualCodeGrepper.exe之參數應用\n三種報告結果呈現如下：\n .txt   .csv   .xml  下方為VCG Github連結，將有更詳細的相關應用資訊 nccgroup/VCG VisualCodeGrepper - Code security scanning tool.\n以上為Jenkins整合Visual Code Grepper自動產出三種格式報告的範例，若有其他應用建議歡迎討論!\n","permalink":"https://GengDeWu.github.io/blog/jenkins_vcg/","tags":["Jenkins","Visual Code Grepper"],"title":"(CI)Jenkins整合Visual Code Grepper源碼檢測工具"},{"categories":["Windows Service"],"contents":"本篇同步發佈在Medium平台上 Medium連結 因Windows Service無法直接運行Debug模式，若直接執行則會跳出以上錯誤訊息，但其實只需稍微調整也能讓Windows Service用Console Application的方式來執行，非常方便！\nStep1. 調整Service1.cs\rStep2. 調整Program.cs\rStep3. 調整Windows Service project輸出類型\r Step1. 調整Service1.cs  在Windows Service專案主要服務類別加入紅框中的Start、Stop方法  Step2. 調整Program.cs  在Windows Service專案的進入點加入紅框內容  (Note:Environment.UserInteractive屬性可得知目前的處理程序是否正執行於使用者互動模式中，若在Windows Service執行時該屬性為false)\nStep3. 調整Windows Service project輸出類型  開啟Windows Service專案屬性，將輸出類型調整為主控台應用程式  完成以上動作後就可將Windows Service用Console Application的方式來執行啦！\n","permalink":"https://GengDeWu.github.io/blog/windows_service_debug/","tags":["Windows Service","Debug"],"title":"Windows Service in Debug Mode"},{"categories":["Hugo"],"contents":"本篇僅發佈在Medium平台上 Medium連結 ","permalink":"https://GengDeWu.github.io/blog/github_hugo/","tags":["Git","Github","Hugo"],"title":"運用Github+Hugo免費部署靜態網站"},{"categories":["Jenkins"],"contents":"本篇僅發佈在Medium平台上 Medium連結 ","permalink":"https://GengDeWu.github.io/blog/jenkins_svn_smtp/","tags":["Jenkins","SVN","SMTP","MSBuild"],"title":"(CI)Jenkins整合SVN、SMTP自動化建置ASP.NET專案"}]