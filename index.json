[{"categories":["Python"],"contents":"本篇同步發佈在 Medium 平台上 Medium 連結 到底這個 if name == \u0026lsquo;main':是什麼意思呢 ?\n首先，如果你永遠都只執行一個 Python 檔，而不引用別的 Python 檔案的話，那麼你不必知道這是什麼東西，反之則來好好理解它吧！\n我直接舉一個例子 🌰 首先先創建一個 test_Demo.py 然後寫入以下程式：\n然後執行 test_Demo.py 會得到：\n Taiwan main Taiwan Number Taiwan Number One !  接著在同一層的資料夾中建立名稱為 import_test_Demo.py 的檔案，寫入以下程式：\n然後執行 import_test_Demo.py 會得到：\n Taiwan test_Demo  簡而言之 name 會是當前檔案名稱，當檔案被直接運行時檔案名稱將為main 。 因此，\n 「單獨執行」時程式將被運行，if name == \u0026lsquo;main\u0026lsquo;成立 「被引用」時程式不被運行，if name == \u0026lsquo;main\u0026lsquo;不成立  為什麼要有 if name == \u0026lsquo;main'? 在於獨立撰寫一些 funtion 時，可以直接執行 funtion 單純的看這個 function 功能是否正常。然而，這一個 function 實際上可能是要給一個大的主程式所使用，如果每一次都要檢查 function 是否正常，都要執行 main，是一個費時費力的過程，若能直接執行 funtion 檢查功能是否正常，將相對有效率！\n簡而言之，我們透過「if name == \u0026lsquo;main'」來控制 funtion，可以將測試資料放在「if name == \u0026lsquo;main'」的裡面，當單純執行 function 的執行檔時，則會利用測試資料檢測其功能；當利用 main 呼叫 function 操作時，就不會執行測試資料！只會直接執行 main 所想代入之變數，傳到 function 運算後將結果回傳給 main！\n","permalink":"https://GengDeWu.github.io/blog/python_if_name_equal_main/","tags":["pytest","Unittest"],"title":"(Python)What is if __name__ == '__main__' in Python ?"},{"categories":["CSharp"],"contents":"本篇同步發佈在 Medium 平台上 Medium 連結 What is Yield？ Yield 就是 Microsoft .Net 中用來實作 iterator(迭代器) 設計模式的語法糖，透過編譯器幫你轉成較複雜的 Code。\n舉個例子 🌰 從 DB 取出使用者設定的信件排程資訊，每封信件的 Template 可能不同，最後送給寄信服務發送。將如何設計此系統的運作流程呢？\n一般作法: 將全部資料都儲存在 List物件中，最終再 return 到寄信服務，這將可能造成系統吃掉大量的記憶體，甚至發生 System.OutOfMemoryException 的錯誤！\n還沒完全載入 Mail 資訊記憶體就已經攀升至 2G 啦 💥\n使用 Yield 作法: 一樣的情境，只是將 mailList.Add(new Mail()) 改為 yield return new Mail()，執行順序將有明顯的變化，如下圖將會依序執行(1) → (2) → (3) → (4) → (2) → (3) → (4) ……，記憶體的使用也相對平穩許多。\n若有興趣也可以參考 Andrew 的部落格，裡頭清楚的說明編譯器是如何幫你產生繁雜的 IEnumerator 實作方式讓你隨隨便便就可以跟別人宣稱:看! 我的程式有用到 Iterator 這個設計模式喔 XD 🐂🐂🐂\nReference [C#: yield return] #1. How It Work ?\n【C#】Yield Return 與迭代器\n","permalink":"https://GengDeWu.github.io/blog/c_sharp_yield_return_iterator_pattern/","tags":["Yield","Iterator Pattern"],"title":"(C#) Yield Return and Iterator Pattern"},{"categories":["CSharp"],"contents":"本篇同步發佈在 Medium 平台上 Medium 連結 首先，String 與 StringBuilder 是不同的喔！\nString   命名空間:System\n  代表不變的字串，一旦設定好值，就不能更改它。\n  String 是字元的陣列，一個連續的記憶體，當要新增、修改、刪除、變動 String 時，就必須毀掉這個陣列重新建立一個字串，因此很耗效能\n  String 類別 (System) MicroSoft 文件連結\nStringBuilder   命名空間:System.Text\n  表示可變動的字元字串，此類別無法被繼承。\n  使用時機：預期對字串進行大量變更時、預計在迴圈內串連字串時。\n  不是 string，所以需要使用 .ToString() 轉成 String 型態。\n  在 .NET 中使用 StringBuilder 類別 MicroSoft 文件連結\n實際測試 1. 動態字串 Loop 10 次 可以看到兩者花費時間是差不多的，StringBuilder 快 String 一倍。\n2. 動態字串 Loop 100000 次 此時 StringBuilder 已經比 String 快上 1000 多倍了！\n3. 靜態字串 在靜態字串時，String 比 StringBuild 效能來的好！\n 結論：當您要動態處理字串時最好選用 StringBuilder 類別 ，靜態處理字串則選用 String 類別。\n ","permalink":"https://GengDeWu.github.io/blog/c_sharp_string_stringbuilder/","tags":["String","StringBuilder"],"title":"(C#) 動態處理字串 String V.S. StringBuilder 效能"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結 Call Stack 在了解這三樣東西之前，要先知道 JavaScript 是單執行緒 single thread 的程式語言，因此一次只能執行一個任務，而 JavaScript中等待執行的任務會放入一個堆疊，我們叫它為 Call Stack。\n以下是一個Call Stack的範例：\n 最終會依序印出：\nfoo\rbar\rbaz\r 瀏覽器執行上述JavaScript時，Call Stack這個容器是怎麼被操作的呢，讓我們看看下圖詳細的流程吧！\nCallback Queue 簡單來說Callback Queue就是各種非同步事件用來排隊的地方，一般認為就是用以下幾種分出不同的佇列，但實作部份要視瀏覽器決定，其中的順序是依照FIFO(先進先出)，以下是幾種會包含的任務:\n  Events(事件): EventTarget物件非同步分派到對應的Events物件\n  Parsing(解析): HTML parser\n  Callbacks(回調): 呼叫非同步回調函式\n  使用外部資源: 資料庫、檔案、Web I/O\n  DOM處理的反應: 回應DOM處理時的元素對應事件\n  在瀏覽器端的JavaScript程式語言中，除了一般的事件分派外，還有少數幾個內建的API與相關物件有類似的非同步機制，有一些簡單的樣式可以利用它們模擬出非同步的執行程式:\n  setTimeout\n  setInterval\n  XMLHttpRequest\n  requestAnimationFrame\n  WebSocket\n  Worker\n  某些HTML5 API，例如File API、Web Database API\n  有使用onload的API\n  舉個例子：\n假如非同步事件會和同步事件都一起被放進 Call stack，那麼就會造成阻塞blocking，例如我們發出一個HTTP請求，那麼在完成 response 之前，就會因為 JavaScript 單執行緒的特性，我們在網頁上都無法進行其它操作。\n為了避免這種問題，非同步事件裡的回調函式 callback function，它們會進入到 Callback Queue 裡面，等 Call stack 裡面沒有其它任務才會進入到 Call stack 執行。\nEvent Loop 上述提到非同步事件會等 Call stack 裡面沒有其它任務才會進入到 Call stack 執行，就是透過 Event loop 機制去做判斷的，其監測步驟如下:\n 確認 Call stack 裡面有沒有Job，沒有才確認步驟2 確認 Callback Queue 裡面有沒有Job，有的話就把最前面的Job移到 Call stack 執行完該Job，又會再回到步驟1，持續這個Loop  最後，推薦讀者們可以觀看以下影片，講者Philip Roberts搭配了JavaScript運行的動畫講解Event Loop的機制，非常詳細且清楚！\n  ","permalink":"https://GengDeWu.github.io/blog/javascript_eventloop/","tags":["javascript","Call Stack","Callback Queue","Event Loop"],"title":"(JavaScript)Call Stack, Callback Queue, Event Loop in JavaScript"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結 若還不清楚甚麼是提升Hoisting的話，可以先看看之前的介紹喔！因為文章內容有部分相關，所以必須先有 Execution Context 以及 Variable Object 的觀念後，會較能理解本篇的內容。\n1. 作用域Scope 最常見的解釋是：作用域是一個變數的生存範圍，若於作用域之外將失去存取此變數的權限。\n馬上來看一個範例：\n 在這段程式中，定義outer與inner兩個函式，並且都在自已的函式中宣告一個變數，但當我們執行到console.log (y) 時會出現Uncaught ReferenceError: y is not defined。\n這其實是因為 y 並不在outer的作用域中，所以他沒有存取 y變數的權限。但為什麼inner卻能夠存取到outer的 x 變數呢 ? 這是因為在inner的作用域中找不到 x 變數，所以JavaScript Engine試著向外尋找 x 變數，最後在outer中找到，最後便能印出1443的訊息！\n靜態作用域與動態作用域 JavaScript採用的是靜態作用域，函式的作用域在函式定義時就決定了。 而靜態作用域相對的是動態作用域，函式的作用 域是在函式呼叫的時候才決定的。 讓我們看一個例子來理解靜態作用域和動態作用域之間的區別：\n 上面的程式碼中：\n  第1行，定義了一個value，並賦值為1；\n  第3~5行，宣告一個函式funB，函式的功能是列印 value 這個變數的值;\n  第7~9行，宣告一個函式funA，函式內部重新建立了一個變數 value 這個變數賦值為2；在函式內部執行了 funB() 這個函式；\n  第12行，執行 funA() 這個函式\n   JavaScript採用的是靜態作用域，以下僅是為了解析兩者流程上的差異！\n 假設JavaScript採用靜態作用域，讓我們解析執行過程：\n執行funB函式，首先從 funB 函式內部查詢是否有變數 value ，如果沒有就根據撰寫的位置，查詢上面一層的程式碼，我們發現value等於1，所以結果會印出 1。\n假設JavaScript採用動態作用域，讓我們解析執行過程：\n執行funB函式，依然是從 funB 函式內部查詢是否有區域性變數 value。如果沒有， 就從呼叫函式的作用域，也就是從 funA 函式內部 查詢 value 變數，所以結果會印出 2。\n2. 閉包Closure 用一句話解釋閉包：閉包就是一個作用域，當今天一個函式在返回一個作用域的時候，變數就會被存在作用域的裡面，不會被回收。\n想必目前應該是有看沒有懂，讓我們用範例來解釋甚麼是返回一個作用域，甚麼是變數就會被存在作用域的裡面不會被回收！\n馬上來看以下的範例，下方的outer(666)這時候到底是甚麼呢？Console.log它結果馬上揭曉！\n 原來這時的outer(666)返回了一個inner函式[作用域]，剛剛的第一個問題返回一個作用域馬上獲得了解釋！\n 接下來，執行這段程式碼，神奇的事情發生了，那就是程式碼依舊輸出了 1443。\n神奇在哪裡？神奇在一個 function 執行完成以後本來會把所有相關的資源釋放掉，可是我 outer 函式已經執行結束了，照理來說變數 x, y的記憶體空間也會被釋放，但我呼叫 inner 函式的時候居然還存取得到 x, y！\n換句話說，x, y這兩個變數被「關在」inner 這個 function 裡面了，所以只要 inner 還存在的一天，x, y就永無安寧，只能一直被關 在裡面。\n而事情的主因就是我在 function 裡面回傳了一個 function，才能造成這種明明執行完畢卻還有東西被關住的現象，而這種情形就是一 般人所熟知的閉包，Closure。\n以上便解釋了變數就會被存在作用域的裡面不會被回收！\n將上述的例子套上解釋閉包的一句話，便能有豁然開朗的感覺！\n閉包就是一個作用域，當今天一個函式outer在返回一個作用域outer(666)的時候，變數x, y就會被存在作用域的裡面，不會被 回收，因此可以正常輸出1433。\n Note：JavaScript Engine的垃圾回收機制會釋放不再使用的記憶體，但閉包為了保留函式和存取其語彙範疇的能力，就會予以保留， 不做記憶體回收。因此 inner 仍然保留指向 outer 內層範疇的參考，這個參考就是閉包。\n ","permalink":"https://GengDeWu.github.io/blog/javascript_scope_closure/","tags":["javascript","scope","closure"],"title":"(JavaScript)What is a closure? 解析作用域Scope \u0026 閉包Closure"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結  在前一篇有提到pass by reference與pass by sharing的原理，那當我們要拷貝物件型別的資料時該如何實作呢，以下就讓我們來看看吧!\n 淺拷貝 Array  使用arr.slice(0)   使用展開運算子[…arr]   Object  使用Object.assign({}, obj1)   使用展開運算子{…obj}   淺拷貝會遇到的問題 當物件中含有物件時，淺拷貝僅能拷貝物件的第一層，第二層之後它的記憶體位址還是指向相同位置，如下範例：\n 深拷貝 透過Lodash Library來做深拷貝，網址如下：\nLodash A JavaScript utility library delivering consistency, modularity, performance, \u0026amp; extras.\n在第8行使用Lodash CDN引入，在第18行使用 _.cloneDeep(obj1); 做深拷貝的動作，就能將多層物件通通都拷貝啦!\n Lodash也提供了相當多實用的函式，對經常處理資料的使用者可以省去很多時間，Lodash Methods 共分為以下幾種，若有興趣可至Lodash網站深入研究喔!\n- Array\r- Collection\r- Date\r- Function\r- Lang\r- Math\r- Number\r- Object\r- Seq\r- String\r- Util\r- Properties\r- Methods\r ","permalink":"https://GengDeWu.github.io/blog/javascript_shallowcopy_deepcopy_lodash/","tags":["javascript","Pass by value","Pass by reference","Pass by sharing","Shallow Copy","Deep Copy","Lodash"],"title":"(JavaScript)淺拷貝Shallow Copy \u0026 深拷貝Deep Copy — 使用Lodash來處理資料吧!"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結  這篇希望能透過一些簡單的範例，讓讀者們能夠輕易了解JavaScript的語言特性。\n Data Type 在JavaScript裡，有多種的資料型別(Data Type)，但主要分為兩大類，一類是原始型別(Primitive Type)，另一類是物件型別(Object Type)。\n原始型別 Primitive Type   String\n  BigInt\n  Number\n  Boolean\n  Null\n  Undefined\n  Symbol（ 在 ECMAScript 6 定義）\n  物件型別 Object Type  Primitive type以外的，例如object, array, function …等   一般來說，Primitive Type會是pass by value，而Object Type則會是pass by reference，以下會用幾個簡單例子來示範。\n 1. 原始型別 Pass by value 變數、記憶體位址、值 首先，要先來了解在電腦的底層世界，想像記憶體空間就像是一個一個的空間，每一個空間都有他的位址，並可以在該空間內儲存值。為了方便取用，才有了「變數」的存在，拿來連結(指向)這些記憶體位址，宣告變數賦值，就是向電腦要一個記憶體空間來儲存值。\n var a = \u0026lsquo;jerry\u0026rsquo;; ，其實是變數 a 指向電腦中某記憶體的位置(ex: 0x01) ，在這個記憶體位置中，儲存 jerry這個值。\n如果我再宣告了一個 var b = a; ，雖然 b 和 a 的值一樣都是 \u0026lsquo;jerry\u0026rsquo; ，但其實變數 b 是指向了另一個不一樣的記憶體位置 (ex:0x02)，把 a 的值 copy 過來存，a 和 b 是存在於兩個獨立不同的記憶體位置中：\n在第7行b = \u0026lsquo;tony\u0026rsquo;;，則是將記憶體位址0x02儲存的值賦予為tony，如下圖 :\n2. 物件型別 Pass by reference  var arr1 = [1,2,3]; ，表示 arr1 指向一個新的記憶體位置(ex: 0x01)，如果再建立第二個陣列並且讓他等於 arr1： var arr2 = arr1; ，這時 arr2 則會直接指向 arr1 的記憶體位置(0x01)，所以不論 arr1 儲存的值為多少， arr2 都會得到一樣的值：\n 在第3行arr2[0] = 666;，則是將記憶體位址0x01儲存的值index 0 賦予為666，如下圖 :\n3. Pass by sharing pass by sharing 的定義就有點像融合了pass by value 和 pass by reference：\n  碰到原始型別，表現行為是 pass by value。\n  碰到物件型別，如果只是改變內容，表現行為是 pass by reference，但是如果對物件作重新賦值，表現行為是 pass by value。\n  所以才會出現這一派的論點，覺得 Javascript 其實是 pass by sharing。\n 以下的流程分解圖可以更清楚了解物件指向的記憶體位置!\n第1～4行\n第5行\n第6行，改變內容(pass by reference)\n第7～10行，重新賦值(pass by value)\n第11行\n由以上範例可得知，book 在第6行被改變內容(pass by reference)，在第7~10行被重新賦值(pass by value)，因此bookObj1、bookObj2最終才會有此差異。\n 結論：在不管名詞定義為何(有些人認為只有pass by sharing)，先以行為來分類的話，primitive type基本上是pass by value，而object基本上是 pass by reference，唯一要注意的是重新賦值這個動作造成reference改變所造成的影響。\n 下一篇將會來討論：淺拷貝Shallow Copy \u0026amp; 深拷貝Deep Copy，並且使用Lodash來處理資料\n","permalink":"https://GengDeWu.github.io/blog/javascript_passbyvalue_reference_sharing/","tags":["javascript","Pass by value","Pass by reference","Pass by sharing"],"title":"(JavaScript)傳值 Pass by value、傳址 Pass by reference以及Pass by sharing"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結 用Javascript來做加減乘除，如果是使用小數的話，跑出來的數字會非常奇特，主要問題在於Javascript運算是依循IEEE754的規範，在運算時會轉換成二進制來計算數值，而浮點數在轉成二進制時會形成無窮迴圈，最後再轉換成十進制，進而產生運算誤差。\n舉個例子，0.1 + 0.2，在Javascript會是這樣子計算的。\n解決方法  1. 引入math.js\n 詳細流程可以參考此篇文章 优秀的js拓展数学库math.js，解决精度问题\n 2. 自訂加減乘除運算程式碼\n 加.add()、減.sub()、乘.mul()、除.div()\n 引入下方的javascript就能正常使用加減乘除運算啦!\n ","permalink":"https://GengDeWu.github.io/blog/javascript_float_calculation/","tags":["javascript"],"title":"(JavaScript)JavaScript 浮點數陷阱/解決方法"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結 What is hoisting? 在JavaScript中宣告的變數和函式，會被JavaScript直譯器 (interpreter) 先處理，換句話說，當你在 global 或 function 任何一個位置宣告變數，就像在該 scope 最頂端的位置宣告一樣，這種特性就叫做 Hoisting (提升)。\n在我們定義變數、函式的過程中，可以分成 宣告(declaration) 和 賦值(initialization) 兩個過程，只有宣告的內容會在逐行執行程式前先被執行並儲存在記憶體中(hoisting)；賦值的內容則是在hoisting後，逐行執行程式時，才會被執行到。\n大綱   (var)變數宣告的提升\n  (function)函式宣告的提升\n  (let/const)宣告與Temporal Dead Zone\n  1. (var)變數宣告的提升  正常印出值\n   印出undefined\n   從編譯器的角度來看\n  2. (function)函式宣告的提升 透過以下的幾個例子，可以得知變數的提升只有宣告部份，而函式的提升是整個函式，因此函式在宣告前是可以執行的。\n           3. (let/const)宣告與Temporal Dead Zone let 與 const 也有 hoisting，與 var 的差異在於提升之後，var 宣告的變數會變為 undefined，而 let 與 const 的宣告不會變為 undefined，且在「提升之後」、「賦值之前」的這段期間就存取它，就會拋出錯誤，而這段期間就稱做是 TDZ(Temporal Dead Zone)。\n  ","permalink":"https://GengDeWu.github.io/blog/javascript_hoisting/","tags":["javascript","hoisting"],"title":"(JavaScript)What is hoisting in JavaScript?"},{"categories":["SQL Server"],"contents":"本篇同步發佈在Medium平台上 Medium連結 在使用SQL Server資料庫時，若該環境是多人共用且大家都使用最高權限的帳號在操作資料庫時，就有機會發生資料庫被誤刪的情況，本篇僅能查出是哪位User(Login SQL Server Account)哪台Computer(HostName)做了刪除動作，要確保資料庫的安危還是需定期備份並且做好帳號的權限管理才是比較正確的做法。\n前置動作(產出Creat/Drop事件)   使用sa帳號登入SQL Server\n  建立一個名稱為TestDropDB的資料庫\n  使用test001帳號登入SQL Server\n  刪除TestDropDB資料庫\n  Step1. 確認SQL Server Log路徑  Step2. 顯示出要查詢的資料庫事件  以上就能很清楚的看到TestDropDB先被主機名稱為MSI、SQL Server帳號為sa的使用者建立，再被主機名稱為MSI、SQL Server帳號為test001的使用者給刪除。\n","permalink":"https://GengDeWu.github.io/blog/sql_server_find_which_user_deleted_the_database/","tags":["SQL Server"],"title":"(SQL Server)How to Find which user deleted the database in SQL Server"},{"categories":["SQL Server"],"contents":"本篇同步發佈在Medium平台上 Medium連結 第一次安裝完Microsoft SQL Server登入時可能會遇到Error 18456的問題\n發生原因 使用SQL Server驗證，因沒有設定使用SQL Server 驗證登入，進而產生(Microsoft SQL Server, 錯誤: 18456)\n解決方法  先使用Window驗證進行登入  對資料庫點擊右鍵並選擇屬性  選擇安全性 → 伺服器驗證區塊勾選SQL Server 及 Windows驗證模式(S) → 確定  會跳出此提示訊息，必須重啟SQL Server Service後上述的設定才會生效  在重啟服務之前我們先確認SQL Server登入帳號是否有啟用，安全性 → 找到要登入的帳號名稱 → 點擊右鍵選擇[屬性]  選擇狀態 → 登入區塊勾選已啟用(E) → 確定  對資料庫點擊右鍵並選擇重新啟動  點選[是]，便會開始重啟SQL Server Service  完成以上流程就能使用SQL Server驗證登入啦!  ","permalink":"https://GengDeWu.github.io/blog/sql_server_error_18456/","tags":["SQL Server"],"title":"(SQL Server) Microsoft SQL Server Error 18456"},{"categories":["IFTTT"],"contents":"本篇同步發佈在Medium平台上 Medium連結 IFTTT是個網路服務平台，縮寫的意思是IF(if)T(this)T(then)T(that)，顧名思義就是「如果這樣然後就那樣」，例如：如果時間到17:30然後Line發訊息通知我該下班了！\n在不用寫什麼程式的情況下，只需有IFTTT以及Line就能輕鬆實現「觸發某件事時，就自動發送Line通知訊息給某人/群組」。\n以下就讓我們來看如何輕鬆地完成這些設定，讓你/妳的生活更加方便吧！\n1. 進入IFTTT網站點選「Sign up」註冊帳號並登入 IFTTT Get started with IFTTT, the easiest way to do more with your favorite apps and devices for free.\n登入後選擇Get more便能瀏覽IFTTT目前能夠串連的服務\n今天的主題是要串連Line，我們點選Services頁籤並搜尋「Line」，便能選擇Line Service。\n點選Line後可以看到一個 Connect 按鈕，點選 Connect 就可以連結 LINE 官方所提供的 Notify 通知服務。\n登入你的Line帳號\n登入後點選「同意並連動」，同時LINE Notify會發給你一則訊息**「已完成與「IFTTT」的連動。請將此帳號邀請至欲接收訊息的LINE群組中。」**，之後就是LINE Notify這個好友會發送通知給你。\n2. 點選右上角的Create開始打造你的第一個IFTTT服務吧 點選+的圖示，設定觸發條件\n我想創建一個當時間一到就通知我下班的IFTTT服務，因此我輸入**「**date**」**並搜尋，點選Date \u0026amp; Time\n此處我選擇 Every day of the week at 並且設定我想收到通知的時間\n點選+的圖示，設定通知方式\n我想由Line通知我訊息，因此我輸入**「line」**並搜尋，點選Line\n點選Send message\n Recipient:選擇要傳送的群組 Message:輸入想收到的訊息 Photo URL:輸入圖片URL\n 編輯完成後點選Create action便完成設定啦!\n成功在設定的時間收到Line Notify通知訊息啦!\nIFTTT的應用非常廣泛且多元，也歡迎大家分享實用的IFTTT唷!\n","permalink":"https://GengDeWu.github.io/blog/ifttt_line_notify/","tags":["IFTTT","Line Notify"],"title":"IFTTT Use Line Notify"},{"categories":["Jenkins"],"contents":"本篇同步發佈在Medium平台上 Medium連結 Visual Code Grepper(VCG) 這套免費的源碼檢測工具，在功能性與準確性上並不輸給動輒幾百萬的商業檢測工具，唯一的差別應該只在於商業工具會提供較完美的圖表測試報告。\n本篇將示範Jenkins整合Visual Code Grepper自動產出三種格式(.txt、.csv、.xml)的報告。\n1. 首先必需先下載Visual Code Grepper Download VisualCodeGrepper V2.2.0 for free. Code security review tool for C/C++, C#, VB, PHP, Java, PL/SQL, COBOL.\n2. 找到VisualCodeGrepper.exe存放的位置 3. 在Jenkins專案中加入執行Windows批次指令   VCGPath：VisualCodeGrepper.exe的位置\n  Scan：要掃描的程式碼位置\n  ResTXT、ResCSV、ResXML：產出報告的位置\n  下方為VisualCodeGrepper.exe之參數應用\n三種報告結果呈現如下：\n .txt   .csv   .xml  下方為VCG Github連結，將有更詳細的相關應用資訊 nccgroup/VCG VisualCodeGrepper - Code security scanning tool.\n以上為Jenkins整合Visual Code Grepper自動產出三種格式報告的範例，若有其他應用建議歡迎討論!\n","permalink":"https://GengDeWu.github.io/blog/jenkins_vcg/","tags":["Jenkins","Visual Code Grepper"],"title":"(CI)Jenkins整合Visual Code Grepper源碼檢測工具"},{"categories":["Windows Service"],"contents":"本篇同步發佈在Medium平台上 Medium連結 因Windows Service無法直接運行Debug模式，若直接執行則會跳出以上錯誤訊息，但其實只需稍微調整也能讓Windows Service用Console Application的方式來執行，非常方便！\nStep1. 調整Service1.cs\rStep2. 調整Program.cs\rStep3. 調整Windows Service project輸出類型\r Step1. 調整Service1.cs  在Windows Service專案主要服務類別加入紅框中的Start、Stop方法  Step2. 調整Program.cs  在Windows Service專案的進入點加入紅框內容  (Note:Environment.UserInteractive屬性可得知目前的處理程序是否正執行於使用者互動模式中，若在Windows Service執行時該屬性為false)\nStep3. 調整Windows Service project輸出類型  開啟Windows Service專案屬性，將輸出類型調整為主控台應用程式  完成以上動作後就可將Windows Service用Console Application的方式來執行啦！\n","permalink":"https://GengDeWu.github.io/blog/windows_service_debug/","tags":["Windows Service","Debug"],"title":"Windows Service in Debug Mode"},{"categories":["Hugo"],"contents":"本篇僅發佈在Medium平台上 Medium連結 ","permalink":"https://GengDeWu.github.io/blog/github_hugo/","tags":["Git","Github","Hugo"],"title":"運用Github+Hugo免費部署靜態網站"},{"categories":["Jenkins"],"contents":"本篇僅發佈在Medium平台上 Medium連結 ","permalink":"https://GengDeWu.github.io/blog/jenkins_svn_smtp/","tags":["Jenkins","SVN","SMTP","MSBuild"],"title":"(CI)Jenkins整合SVN、SMTP自動化建置ASP.NET專案"}]