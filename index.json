[{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結 若還不清楚甚麼是提升Hoisting的話，可以先看看之前的介紹喔！因為文章內容有部分相關，所以必須先有 Execution Context 以及 Variable Object 的觀念後，會較能理解本篇的內容。\n1. 作用域Scope 最常見的解釋是：作用域是一個變數的生存範圍，若於作用域之外將失去存取此變數的權限。\n馬上來看一個範例：\n 在這段程式中，定義outer與inner兩個函式，並且都在自已的函式中宣告一個變數，但當我們執行到console.log (y) 時會出現Uncaught ReferenceError: y is not defined。\n這其實是因為 y 並不在outer的作用域中，所以他沒有存取 y變數的權限。但為什麼inner卻能夠存取到outer的 x 變數呢 ? 這是因為在inner的作用域中找不到 x 變數，所以JavaScript Engine試著向外尋找 x 變數，最後在outer中找到，最後便能印出1443的訊息！\n靜態作用域與動態作用域 JavaScript採用的是靜態作用域，函式的作用域在函式定義時就決定了。 而靜態作用域相對的是動態作用域，函式的作用 域是在函式呼叫的時候才決定的。 讓我們看一個例子來理解靜態作用域和動態作用域之間的區別：\n 上面的程式碼中：\n  第1行，定義了一個value，並賦值為1；\n  第3~5行，宣告一個函式funB，函式的功能是列印 value 這個變數的值;\n  第7~9行，宣告一個函式funA，函式內部重新建立了一個變數 value 這個變數賦值為2；在函式內部執行了 funB() 這個函式；\n  第12行，執行 funA() 這個函式\n   JavaScript採用的是靜態作用域，以下僅是為了解析兩者流程上的差異！\n 假設JavaScript採用靜態作用域，讓我們解析執行過程：\n執行funB函式，首先從 funB 函式內部查詢是否有變數 value ，如果沒有就根據撰寫的位置，查詢上面一層的程式碼，我們發現value等於1，所以結果會印出 1。\n假設JavaScript採用動態作用域，讓我們解析執行過程：\n執行funB函式，依然是從 funB 函式內部查詢是否有區域性變數 value。如果沒有， 就從呼叫函式的作用域，也就是從 funA 函式內部 查詢 value 變數，所以結果會印出 2。\n2. 閉包Closure 用一句話解釋閉包：閉包就是一個作用域，當今天一個函式在返回一個作用域的時候，變數就會被存在作用域的裡面，不會被回收。\n想必目前應該是有看沒有懂，讓我們用範例來解釋甚麼是返回一個作用域，甚麼是變數就會被存在作用域的裡面不會被回收！\n馬上來看以下的範例，下方的outer(666)這時候到底是甚麼呢？Console.log它結果馬上揭曉！\n 原來這時的outer(666)返回了一個inner函式[作用域]，剛剛的第一個問題返回一個作用域馬上獲得了解釋！\n 接下來，執行這段程式碼，神奇的事情發生了，那就是程式碼依舊輸出了 1443。\n神奇在哪裡？神奇在一個 function 執行完成以後本來會把所有相關的資源釋放掉，可是我 outer 函式已經執行結束了，照理來說變數 x, y的記憶體空間也會被釋放，但我呼叫 inner 函式的時候居然還存取得到 x, y！\n換句話說，x, y這兩個變數被「關在」inner 這個 function 裡面了，所以只要 inner 還存在的一天，x, y就永無安寧，只能一直被關 在裡面。\n而事情的主因就是我在 function 裡面回傳了一個 function，才能造成這種明明執行完畢卻還有東西被關住的現象，而這種情形就是一 般人所熟知的閉包，Closure。\n以上便解釋了變數就會被存在作用域的裡面不會被回收！\n將上述的例子套上解釋閉包的一句話，便能有豁然開朗的感覺！\n閉包就是一個作用域，當今天一個函式outer在返回一個作用域outer(666)的時候，變數x, y就會被存在作用域的裡面，不會被 回收，因此可以正常輸出1433。\n Note：JavaScript Engine的垃圾回收機制會釋放不再使用的記憶體，但閉包為了保留函式和存取其語彙範疇的能力，就會予以保留， 不做記憶體回收。因此 inner 仍然保留指向 outer 內層範疇的參考，這個參考就是閉包。\n ","permalink":"https://GengDeWu.github.io/blog/javascript_scope_closure/","tags":["javascript","scope","closure"],"title":"(JavaScript)What is a closure? 解析作用域Scope \u0026 閉包Closure"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結  在前一篇有提到pass by reference與pass by sharing的原理，那當我們要拷貝物件型別的資料時該如何實作呢，以下就讓我們來看看吧!\n 淺拷貝 Array  使用arr.slice(0)   使用展開運算子[…arr]   Object  使用Object.assign({}, obj1)   使用展開運算子{…obj}   淺拷貝會遇到的問題 當物件中含有物件時，淺拷貝僅能拷貝物件的第一層，第二層之後它的記憶體位址還是指向相同位置，如下範例：\n 深拷貝 透過Lodash Library來做深拷貝，網址如下：\nLodash A JavaScript utility library delivering consistency, modularity, performance, \u0026amp; extras.\n在第8行使用Lodash CDN引入，在第18行使用 _.cloneDeep(obj1); 做深拷貝的動作，就能將多層物件通通都拷貝啦!\n Lodash也提供了相當多實用的函式，對經常處理資料的使用者可以省去很多時間，Lodash Methods 共分為以下幾種，若有興趣可至Lodash網站深入研究喔!\n- Array\r- Collection\r- Date\r- Function\r- Lang\r- Math\r- Number\r- Object\r- Seq\r- String\r- Util\r- Properties\r- Methods\r ","permalink":"https://GengDeWu.github.io/blog/javascript_shallowcopy_deepcopy_lodash/","tags":["javascript","Pass by value","Pass by reference","Pass by sharing","Shallow Copy","Deep Copy","Lodash"],"title":"(JavaScript)淺拷貝Shallow Copy \u0026 深拷貝Deep Copy — 使用Lodash來處理資料吧!"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結  這篇希望能透過一些簡單的範例，讓讀者們能夠輕易了解JavaScript的語言特性。\n Data Type 在JavaScript裡，有多種的資料型別(Data Type)，但主要分為兩大類，一類是原始型別(Primitive Type)，另一類是物件型別(Object Type)。\n原始型別 Primitive Type   String\n  BigInt\n  Number\n  Boolean\n  Null\n  Undefined\n  Symbol（ 在 ECMAScript 6 定義）\n  物件型別 Object Type  Primitive type以外的，例如object, array, function …等   一般來說，Primitive Type會是pass by value，而Object Type則會是pass by reference，以下會用幾個簡單例子來示範。\n 1. 原始型別 Pass by value 變數、記憶體位址、值 首先，要先來了解在電腦的底層世界，想像記憶體空間就像是一個一個的空間，每一個空間都有他的位址，並可以在該空間內儲存值。為了方便取用，才有了「變數」的存在，拿來連結(指向)這些記憶體位址，宣告變數賦值，就是向電腦要一個記憶體空間來儲存值。\n var a = \u0026lsquo;jerry\u0026rsquo;; ，其實是變數 a 指向電腦中某記憶體的位置(ex: 0x01) ，在這個記憶體位置中，儲存 jerry這個值。\n如果我再宣告了一個 var b = a; ，雖然 b 和 a 的值一樣都是 \u0026lsquo;jerry\u0026rsquo; ，但其實變數 b 是指向了另一個不一樣的記憶體位置 (ex:0x02)，把 a 的值 copy 過來存，a 和 b 是存在於兩個獨立不同的記憶體位置中：\n在第7行b = \u0026lsquo;tony\u0026rsquo;;，則是將記憶體位址0x02儲存的值賦予為tony，如下圖 :\n2. 物件型別 Pass by reference  var arr1 = [1,2,3]; ，表示 arr1 指向一個新的記憶體位置(ex: 0x01)，如果再建立第二個陣列並且讓他等於 arr1： var arr2 = arr1; ，這時 arr2 則會直接指向 arr1 的記憶體位置(0x01)，所以不論 arr1 儲存的值為多少， arr2 都會得到一樣的值：\n 在第3行arr2[0] = 666;，則是將記憶體位址0x01儲存的值index 0 賦予為666，如下圖 :\n3. Pass by sharing pass by sharing 的定義就有點像融合了pass by value 和 pass by reference：\n  碰到原始型別，表現行為是 pass by value。\n  碰到物件型別，如果只是改變內容，表現行為是 pass by reference，但是如果對物件作重新賦值，表現行為是 pass by value。\n  所以才會出現這一派的論點，覺得 Javascript 其實是 pass by sharing。\n 以下的流程分解圖可以更清楚了解物件指向的記憶體位置!\n第1～4行\n第5行\n第6行，改變內容(pass by reference)\n第7～10行，重新賦值(pass by value)\n第11行\n由以上範例可得知，book 在第6行被改變內容(pass by reference)，在第7~10行被重新賦值(pass by value)，因此bookObj1、bookObj2最終才會有此差異。\n 結論：在不管名詞定義為何(有些人認為只有pass by sharing)，先以行為來分類的話，primitive type基本上是pass by value，而object基本上是 pass by reference，唯一要注意的是重新賦值這個動作造成reference改變所造成的影響。\n 下一篇將會來討論：淺拷貝Shallow Copy \u0026amp; 深拷貝Deep Copy，並且使用Lodash來處理資料\n","permalink":"https://GengDeWu.github.io/blog/javascript_passbyvalue_reference_sharing/","tags":["javascript","Pass by value","Pass by reference","Pass by sharing"],"title":"(JavaScript)傳值 Pass by value、傳址 Pass by reference以及Pass by sharing"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結 用Javascript來做加減乘除，如果是使用小數的話，跑出來的數字會非常奇特，主要問題在於Javascript運算是依循IEEE754的規範，在運算時會轉換成二進制來計算數值，而浮點數在轉成二進制時會形成無窮迴圈，最後再轉換成十進制，進而產生運算誤差。\n舉個例子，0.1 + 0.2，在Javascript會是這樣子計算的。\n解決方法  1. 引入math.js\n 詳細流程可以參考此篇文章 优秀的js拓展数学库math.js，解决精度问题\n 2. 自訂加減乘除運算程式碼\n 加.add()、減.sub()、乘.mul()、除.div()\n 引入下方的javascript就能正常使用加減乘除運算啦!\n ","permalink":"https://GengDeWu.github.io/blog/javascript_float_calculation/","tags":["javascript"],"title":"(JavaScript)JavaScript 浮點數陷阱/解決方法"},{"categories":["javascript"],"contents":"本篇同步發佈在Medium平台上 Medium連結 What is hoisting? 在JavaScript中宣告的變數和函式，會被JavaScript直譯器 (interpreter) 先處理，換句話說，當你在 global 或 function 任何一個位置宣告變數，就像在該 scope 最頂端的位置宣告一樣，這種特性就叫做 Hoisting (提升)。\n在我們定義變數、函式的過程中，可以分成 宣告(declaration) 和 賦值(initialization) 兩個過程，只有宣告的內容會在逐行執行程式前先被執行並儲存在記憶體中(hoisting)；賦值的內容則是在hoisting後，逐行執行程式時，才會被執行到。\n大綱   (var)變數宣告的提升\n  (function)函式宣告的提升\n  (let/const)宣告與Temporal Dead Zone\n  1. (var)變數宣告的提升  正常印出值\n   印出undefined\n   從編譯器的角度來看\n  2. (function)函式宣告的提升 透過以下的幾個例子，可以得知變數的提升只有宣告部份，而函式的提升是整個函式，因此函式在宣告前是可以執行的。\n           3. (let/const)宣告與Temporal Dead Zone let 與 const 也有 hoisting，與 var 的差異在於提升之後，var 宣告的變數會變為 undefined，而 let 與 const 的宣告不會變為 undefined，且在「提升之後」、「賦值之前」的這段期間就存取它，就會拋出錯誤，而這段期間就稱做是 TDZ(Temporal Dead Zone)。\n  ","permalink":"https://GengDeWu.github.io/blog/javascript_hoisting/","tags":["javascript","hoisting"],"title":"(JavaScript)What is hoisting in JavaScript?"},{"categories":["SQL Server"],"contents":"本篇同步發佈在Medium平台上 Medium連結 在使用SQL Server資料庫時，若該環境是多人共用且大家都使用最高權限的帳號在操作資料庫時，就有機會發生資料庫被誤刪的情況，本篇僅能查出是哪位User(Login SQL Server Account)哪台Computer(HostName)做了刪除動作，要確保資料庫的安危還是需定期備份並且做好帳號的權限管理才是比較正確的做法。\n前置動作(產出Creat/Drop事件)   使用sa帳號登入SQL Server\n  建立一個名稱為TestDropDB的資料庫\n  使用test001帳號登入SQL Server\n  刪除TestDropDB資料庫\n  Step1. 確認SQL Server Log路徑  Step2. 顯示出要查詢的資料庫事件  以上就能很清楚的看到TestDropDB先被主機名稱為MSI、SQL Server帳號為sa的使用者建立，再被主機名稱為MSI、SQL Server帳號為test001的使用者給刪除。\n","permalink":"https://GengDeWu.github.io/blog/sql_server_find_which_user_deleted_the_database/","tags":["SQL Server"],"title":"(SQL Server)How to Find which user deleted the database in SQL Server"},{"categories":["SQL Server"],"contents":"本篇同步發佈在Medium平台上 Medium連結 第一次安裝完Microsoft SQL Server登入時可能會遇到Error 18456的問題\n發生原因 使用SQL Server驗證，因沒有設定使用SQL Server 驗證登入，進而產生(Microsoft SQL Server, 錯誤: 18456)\n解決方法  先使用Window驗證進行登入  對資料庫點擊右鍵並選擇屬性  選擇安全性 → 伺服器驗證區塊勾選SQL Server 及 Windows驗證模式(S) → 確定  會跳出此提示訊息，必須重啟SQL Server Service後上述的設定才會生效  在重啟服務之前我們先確認SQL Server登入帳號是否有啟用，安全性 → 找到要登入的帳號名稱 → 點擊右鍵選擇[屬性]  選擇狀態 → 登入區塊勾選已啟用(E) → 確定  對資料庫點擊右鍵並選擇重新啟動  點選[是]，便會開始重啟SQL Server Service  完成以上流程就能使用SQL Server驗證登入啦!  ","permalink":"https://GengDeWu.github.io/blog/sql_server_error_18456/","tags":["SQL Server"],"title":"(SQL Server) Microsoft SQL Server Error 18456"},{"categories":["IFTTT"],"contents":"本篇同步發佈在Medium平台上 Medium連結 IFTTT是個網路服務平台，縮寫的意思是IF(if)T(this)T(then)T(that)，顧名思義就是「如果這樣然後就那樣」，例如：如果時間到17:30然後Line發訊息通知我該下班了！\n在不用寫什麼程式的情況下，只需有IFTTT以及Line就能輕鬆實現「觸發某件事時，就自動發送Line通知訊息給某人/群組」。\n以下就讓我們來看如何輕鬆地完成這些設定，讓你/妳的生活更加方便吧！\n1. 進入IFTTT網站點選「Sign up」註冊帳號並登入 IFTTT Get started with IFTTT, the easiest way to do more with your favorite apps and devices for free.\n登入後選擇Get more便能瀏覽IFTTT目前能夠串連的服務\n今天的主題是要串連Line，我們點選Services頁籤並搜尋「Line」，便能選擇Line Service。\n點選Line後可以看到一個 Connect 按鈕，點選 Connect 就可以連結 LINE 官方所提供的 Notify 通知服務。\n登入你的Line帳號\n登入後點選「同意並連動」，同時LINE Notify會發給你一則訊息**「已完成與「IFTTT」的連動。請將此帳號邀請至欲接收訊息的LINE群組中。」**，之後就是LINE Notify這個好友會發送通知給你。\n2. 點選右上角的Create開始打造你的第一個IFTTT服務吧 點選+的圖示，設定觸發條件\n我想創建一個當時間一到就通知我下班的IFTTT服務，因此我輸入**「**date**」**並搜尋，點選Date \u0026amp; Time\n此處我選擇 Every day of the week at 並且設定我想收到通知的時間\n點選+的圖示，設定通知方式\n我想由Line通知我訊息，因此我輸入**「line」**並搜尋，點選Line\n點選Send message\n Recipient:選擇要傳送的群組 Message:輸入想收到的訊息 Photo URL:輸入圖片URL\n 編輯完成後點選Create action便完成設定啦!\n成功在設定的時間收到Line Notify通知訊息啦!\nIFTTT的應用非常廣泛且多元，也歡迎大家分享實用的IFTTT唷!\n","permalink":"https://GengDeWu.github.io/blog/ifttt_line_notify/","tags":["IFTTT","Line Notify"],"title":"IFTTT Use Line Notify"},{"categories":["Jenkins"],"contents":"本篇同步發佈在Medium平台上 Medium連結 Visual Code Grepper(VCG) 這套免費的源碼檢測工具，在功能性與準確性上並不輸給動輒幾百萬的商業檢測工具，唯一的差別應該只在於商業工具會提供較完美的圖表測試報告。\n本篇將示範Jenkins整合Visual Code Grepper自動產出三種格式(.txt、.csv、.xml)的報告。\n1. 首先必需先下載Visual Code Grepper Download VisualCodeGrepper V2.2.0 for free. Code security review tool for C/C++, C#, VB, PHP, Java, PL/SQL, COBOL.\n2. 找到VisualCodeGrepper.exe存放的位置 3. 在Jenkins專案中加入執行Windows批次指令   VCGPath：VisualCodeGrepper.exe的位置\n  Scan：要掃描的程式碼位置\n  ResTXT、ResCSV、ResXML：產出報告的位置\n  下方為VisualCodeGrepper.exe之參數應用\n三種報告結果呈現如下：\n .txt   .csv   .xml  下方為VCG Github連結，將有更詳細的相關應用資訊 nccgroup/VCG VisualCodeGrepper - Code security scanning tool.\n以上為Jenkins整合Visual Code Grepper自動產出三種格式報告的範例，若有其他應用建議歡迎討論!\n","permalink":"https://GengDeWu.github.io/blog/jenkins_vcg/","tags":["Jenkins","Visual Code Grepper"],"title":"(CI)Jenkins整合Visual Code Grepper源碼檢測工具"},{"categories":["Windows Service"],"contents":"本篇同步發佈在Medium平台上 Medium連結 因Windows Service無法直接運行Debug模式，若直接執行則會跳出以上錯誤訊息，但其實只需稍微調整也能讓Windows Service用Console Application的方式來執行，非常方便！\nStep1. 調整Service1.cs\rStep2. 調整Program.cs\rStep3. 調整Windows Service project輸出類型\r Step1. 調整Service1.cs  在Windows Service專案主要服務類別加入紅框中的Start、Stop方法  Step2. 調整Program.cs  在Windows Service專案的進入點加入紅框內容  (Note:Environment.UserInteractive屬性可得知目前的處理程序是否正執行於使用者互動模式中，若在Windows Service執行時該屬性為false)\nStep3. 調整Windows Service project輸出類型  開啟Windows Service專案屬性，將輸出類型調整為主控台應用程式  完成以上動作後就可將Windows Service用Console Application的方式來執行啦！\n","permalink":"https://GengDeWu.github.io/blog/windows_service_debug/","tags":["Windows Service","Debug"],"title":"Windows Service in Debug Mode"},{"categories":["Hugo"],"contents":"本篇僅發佈在Medium平台上 Medium連結 ","permalink":"https://GengDeWu.github.io/blog/github_hugo/","tags":["Git","Github","Hugo"],"title":"運用Github+Hugo免費部署靜態網站"},{"categories":["Jenkins"],"contents":"本篇僅發佈在Medium平台上 Medium連結 ","permalink":"https://GengDeWu.github.io/blog/jenkins_svn_smtp/","tags":["Jenkins","SVN","SMTP","MSBuild"],"title":"(CI)Jenkins整合SVN、SMTP自動化建置ASP.NET專案"}]